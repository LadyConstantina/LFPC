# -*- coding: utf-8 -*-
"""Parser2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OqCMqQJhAbHUyqBYNbFROQGtxYplxCqi
"""

class NonValueReturnableProcess(Exception):
    pass

class MissingReturnStatement(Exception):
    pass

import pprint
import re

class Parser:
    def __init__(self):
        self.ASSERTION_REGEX = '(GT)?\s*(product|quantity)*\s*([0-9a-z_]+)\s+->\s+\[*([a-zA-Z0-9\s+()_,\"\']+)\]*;'
        self.PROCESS_CALL_REGEX = '([A-Z0-9]+)\s*\(([a-zA-Z0-9_,\"\+\s\.]+)\);*'
        self.IF_STATEMENT_REGEX = "IF\s+\([a-z0-9_\s]+\)\{[a-zA-Z0-9_\s\->();]+}\s*(ELSE IF\s+\([a-z0-9_\s]+\)\{[a-zA-Z0-9_\s\->();]+})*"
        self.PARSE_IF_STATEMENT_REGEX = "IF\s+\(([a-z0-9_]+\s*(in|and|or)\s+[a-z0-9_]+)\){\s+([a-zA-Z0-9_\->\s()]+;)\s+}"
        self.ELSE_IF_STATEMENT_REGEX = "ELSE IF\s+\(([a-z0-9_]+\s*(in|and|or)\s+[a-z0-9_]+)\){\s+([a-zA-Z0-9_\->\s()]+;)\s+}"
        self.ARITHMETIC_OP_REGEX = "([a-z0-9_]+)\s*([+\-\*\/])\s*([a-z0-9_]+)"
        self.PROCESS_SEARCH_REGEX = "PROCESS [a-z]+ [0-9A-Z]+ \([a-z,_\s;]+\)\{[a-zA-Z0-9()\"+=.*,;\s+]*\}"
        self.PROCESS_PARSER_REGEX = "PROCESS ([a-z]+) ([0-9A-Z]+) \(((([a-z]+)\s+[a-z_,]+;*\s*)*)\)\{(RETURN)?\s*(.+)\s*\}"
        self.GET_MAIN_REGEX = 'MAIN{.*}'

    def prepare_arguments(self, args_string):
        args_list = []
        args_groups = args_string.split(';')

        for args in args_groups:
            arg_type, *arg_names = tuple(args.split())
            arg_names = ' '.join(arg_names).split(',')
            for arg_name in arg_names:
                args_list.append({
                    "Argument-Name" : arg_name,
                    "Argument-Type" : arg_type
                })
        return args_list

    def extract_processes(self, code):
        code = code.replace('<break_line>', ' ')
        processes = re.findall(self.PROCESS_SEARCH_REGEX, code)
        processes_data = []
        for process in processes:
            groups = re.search(self.PROCESS_PARSER_REGEX, process).groups()

            # Checking for errors.
            if "RETURN" in groups[-1] and groups[0] == 'empty':
                raise NonValueReturnableProcess("empty process doesn't return values")
            elif "RETURN" not in groups[-1] and groups[0] in ['quantity', 'product']:
                raise MissingReturnStatement(f'{groups[0]} process must return a {groups[0]} value')

            processes_data.append(
                {
                    "Node-Type" : "Process",
                    "Return-Type" : groups[0],
                    "Process-Name" : groups[1],
                    "Arguments" : self.prepare_arguments(groups[2]),
                    "Process-Body" : [self.code_executor(line.strip()) for line in groups[-1].strip().split(";")[:-1]]
                }
            )
        return processes_data

    def parse_process_call(self, code):
        groups = re.match(self.PROCESS_CALL_REGEX, code).groups()

        return {
            "Node-Type" : "Process-Call",
            "Process" : groups[0],
            "Process-Parameters" : [param.strip() for param in groups[1].split(',')]
        }

    def parse_assertion(self, code):
        assertion_dict = {}
        groups = re.match(self.ASSERTION_REGEX, code).groups()
        if groups[0]:
            assertion_dict['Node-Type'] = "GT-Assertion"
        else:
            assertion_dict['Node-Type'] = "Var-Assertion"

        assertion_dict['Data-Type'] = groups[1]
        assertion_dict['Var-Name'] = groups[2]
        assertion_dict['Var-Value'] = groups[3]
        assertion_dict['Code'] = code

        if bool(re.match(self.PROCESS_CALL_REGEX, assertion_dict['Var-Value'])):
            assertion_dict['Var-Value'] = self.parse_process_call(assertion_dict['Var-Value'])
        return assertion_dict

    def parse_if_statement(self, code, full_code, index):
        statement = re.search(self.IF_STATEMENT_REGEX, code)
        if_statement = statement.group()
        groups = re.match(self.PARSE_IF_STATEMENT_REGEX, if_statement).groups()
        steps = 0
        for i in range(len(full_code)):
            if full_code[i].strip() in statement.group():
                steps += 1

        if_statement_dict = {
            "Node-Type" : "If-Statement",
            "Logic-Operation" : {
                "Node-Type" : "Logic-Operation",
                "Parameters" : [param.strip() for param in groups[0].split(groups[1])],
            },
            "Code" : self.code_executor(groups[-1])
        }

        if statement.groups()[0]:
            else_if_statement = statement.groups()[0]
            groups = re.match(self.ELSE_IF_STATEMENT_REGEX, else_if_statement).groups()
            else_statement_dict = {
                "Node-Type" : "Else-Statement",
                "Logic-Operation" : {
                    "Node-Type" : "Logic-Operation",
                    "Parameters" : [param.strip() for param in groups[0].split(groups[1])],
                },
                "Code" : self.code_executor(groups[-1])
            }
            if_statement_dict['Else-Case'] = else_statement_dict
        return if_statement_dict, index + steps -1

    def parse_arithmetic(self, code):
        arithmetic = re.search(self.ARITHMETIC_OP_REGEX, code).groups()
        new_code = re.sub(self.ARITHMETIC_OP_REGEX, "<arithmetic>", code)
        return {
            "Node-Type" : "Arithmetic",
            "Code" : new_code,
            "Arguments" : [arithmetic[0], arithmetic[2]],
            "Operation" : arithmetic[1]
        }

    def code_executor(self, code, index=None):
        if index:
            row = code[index].strip()
        else:
            row = code
        if row.strip().startswith('//'):
            return None, index + 1
        elif re.match(self.ASSERTION_REGEX, row):
            if index is None:
                return self.parse_assertion(row)
            else:
                return self.parse_assertion(row), index + 1
        elif "IF" in row:
            code_to_process = ' '.join(code[index:])

            if_dict, new_index = self.parse_if_statement(code_to_process, code, index)
            return if_dict, new_index
        elif re.search(self.ARITHMETIC_OP_REGEX, row):
            return self.parse_arithmetic(row)
        elif re.match(self.PROCESS_CALL_REGEX, row):
            if index is None:
                return self.parse_process_call(row)
            else:
                return self.parse_process_call(row), index + 1
        elif re.match("RETURN [a-z]+", row):
            return {
                "Node-Type" : "Return-Value",
                "Code" : row
            }
        elif row.strip() == '}':
            return {
                "Node-Type" : "Closing-Bracket",
                "Code" : "}"
            }, None

    def parse(self, path):
        parsing_tree = {}

        code = open(path, 'r').read()
        code = ' '.join(code.replace("\n", "<break_line>").split())
        processes = self.extract_processes(code)
        parsing_tree['Processes'] = processes
        main_code = re.findall(self.GET_MAIN_REGEX, code)[0]
        code_by_rows = main_code.split('<break_line>')
        index = 1
        main = []
        while index < len(code_by_rows):
            dicts, index = self.code_executor(code_by_rows, index)
            if dicts is None:
                continue
            main.append(dicts)
            if index is None:
                break
                
        parsing_tree['main'] = main

        return parsing_tree

parser = Parser()
tree = parser.parse('grammar_example.txt')
pprint.pprint(tree)